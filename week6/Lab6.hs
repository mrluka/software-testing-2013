module Lab6

where
import Data.List
import System.Random
import Week6
import Techniques

{- 
Task 1 
  Implement a function exM that does modular exponentiation of x^y 
  in polynomial time, by repeatedly squaring modulo N.
  E.g., x^33 mod 5 can be computed by means of
  x^33 (mod 5) = x^32 (mod 5) * x (mod 5)
  x^32 (mod N) is computed in five steps by means of repeatedly squaring modulo N:
  x (mod N) -> x^2 (mod N) -> x^4  (mod N) -> ...-> x^32 (mod N):
  If this explanation is too concise, look up relevant literature
-}

-- SOLUTION 1 (Source Week6.hs)
exM' :: Integer -> Integer -> Integer -> Integer
exM' _ 0 _ = 1
exM' x y n = let 
             z = exM' x (y `div` 2) n
             w = multM z z n
               in 
               if even y then w
               else multM x w n 


-- SOLUTION 2 (Source: http://rosettacode.org/wiki/Modular_exponentiation#Haskell)
-- exM' :: Integer -> Integer -> Integer -> Integer -> Integer
-- exM' b 0 m r = r
-- exM' b e m r | e `mod` 2 == 1 = exM' (b * b `mod` m) (e `div` 2) m (r * b `mod` m)
-- exM' b e m r = exM' (b * b `mod` m) (e `div` 2) m r


-- SOLUTION 3 (Source: http://en.wikipedia.org/wiki/Modular_exponentiation#Memory-efficient_method)
--functional version of the algorithm found on wikipedia 
-- exM' :: Integer -> Integer -> Integer -> Integer
-- exM' base exponent modulus = exMR 0 1 base exponent modulus 

-- exMR :: Integer -> Integer -> Integer -> Integer -> Integer -> Integer
-- exMR i c base exponent modulus = if i < exponent
-- 				  then exMR (i + 1) (mod (c * base) modulus) base exponent modulus
-- 				  else c

-- random tests to assure that our implementation comes up with the same result as the 'regular' mod operation

-- perform 10000 random tests
doRandomTests :: IO Bool
doRandomTests = doRandomTestsR 10000

-- perform a given number of random tests
doRandomTestsR :: Integer-> IO Bool
doRandomTestsR x = 
		      if x > 0 
		      then 
		      do r <- doRandomTest
		         p <- (doRandomTestsR (x - 1))
		         return (p && r)
		      else return True

-- perform a single random test
doRandomTest :: IO Bool
doRandomTest = do  
		   x <- (getRandomInt 1000)
		   y <- (getRandomInt 1000) 
		   z <- (getRandomInt 1000) 
		   if 
		    toInteger(expM (toInteger(x+1)) (toInteger(y+1)) (toInteger(z+1)))
		      == 
--		    toInteger((exM' (toInteger(x+1)) (toInteger(y+1)) (toInteger(z+1))) 1) -- Solution  2
		    toInteger((exM' (toInteger(x+1)) (toInteger(y+1)) (toInteger(z+1)))) -- Solution 1 & 3
		   then return True
		   else error ("exM gives not the same result as expM for "	 ++ (show (x+1)) ++ " , "  ++ (show (y+1)) ++ " ," ++ (show (z+1)))

{- 
Task2 : 
  Check that your implementation is more efficient than expM by 
  running a number of relevant tests and documenting the results.
-}

{-
Bad news! It's slower and less efficient! :(  

*Lab6> expM 5 5000000 3			1	( 0.15 secs,   25264776 bytes)
*Lab6> Lab6.exM 5 5000000 3		1	(11.54 secs, 2459061640 bytes)

*Lab6> expM 537 5000000 319		199	( 0.74 secs,   99215856 bytes)
*Lab6> Lab6.exM 537 5000000 319 	199	(11.20 secs, 2458988504 bytes)

*Lab6> expM 537 50000000 319		23	(9.50 secs, 1053698392 bytes)
*Lab6> Lab6.exM 537 50000000 319 	*** Exception: stack overflow


--------Luka
*Lab6> expM 5 5000000 3			1	(0.44 secs, 25210884 bytes)
*Lab6> Lab6.exM 5 5000000 3		1       (8.40 secs, 1167222876 bytes)

*Lab6> expM 537 5000000 319		199	(2.23 secs, 100806448 bytes)
*Lab6> Lab6.exM 537 5000000 319 	199	(8.32 secs, 1167228464 bytes)

*Lab6> expM 537 50000000 319		23	(27.13 secs, 1055892216 bytes)
*Lab6> Lab6.exM 537 50000000 319 	memory allocation failed (requested 2097152 bytes)

-}


{-
Task 3 :
  In order to test Fermat's Primality Check (as implemented in function primeF),
  the list of prime numbers generated by Eratosthenes' sieve is useless, for Fermat's
  Primality Check correctly classify the primes as primes. Where the check can go
  wrong is on classifying composite numbers; these can slip through the Fermat test.
  Write a function composites :: [Integer] that generates the infinite list of composite 
  natural numbers. 
  Hint: modify Eratosthenes' sieve, so that instead of throwing away 
  composite numbers, it marks them as false. Next filter out the numbers marked as false.

Notes (Task 3 & Task 4)
  Test Fermat’s Primality Check (primeF) 
  Eratosthenes’ sieve is useless, it calculates primes as integers above 1 that are not multiples of primes
  Modify Eratosthenes sieve so that it marks compound integers as false 
  Fermat's Primality Check can go wrong 
  Where the check can go wrong is on classifying composite numbers; these can slip through the Fermat test.
  composites :: [Integer] should generate only prime nubers that are composite: integer above 1 that are (!) multiple of primes
  Find integer produced by composites :: [Integer] that fails the primeF test

-}

composites :: [Integer] -- list of prime integers above 1 that are (!) multiple of primes
composites = []


{-
Task 4 :
  Use the list of composite numbers (composites :: [Integer]) to test Fermat's primality check. What is the
  least composite number that you can find that fools the check, for testF k with
  k = 1; 2; 3 ? What happens if you increase k?
-}

{-
Task 5 :
  Use the list generated by the following function for a further test of Fermat's primality check.
  Read the entry on Carmichael numbers on Wikipedia to explain what you find.
-}

carmichael :: [Integer]
carmichael = [ (6*k+1)*(12*k+1)*(18*k+1) | 
      k <- [2..], 
      isPrime (6*k+1), 
      isPrime (12*k+1), 
      isPrime (18*k+1) ]

{-
Task 6 : 
  Use the list from the previous exercise to test the Miller-Rabin primality check.
  What do you find?
-}

{-
Task 7 :
  You can use the Miller-Rabin primality check to discover some large Mersenne
  primes. The recipe: take a large prime p, and use the Miller-Rabin algorithm
  to check whether 2p  1 is also prime. Find information about Mersenne primes
  on internet and check whether the numbers that you found are genuine Mersenne
  primes. Report on your findings.
-}