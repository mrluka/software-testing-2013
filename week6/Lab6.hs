module Lab6

where
import Data.List
import System.Random
import Week6
import Techniques

{-
Time spent:
task 1 & 2 : 7h CK (tests OK, implementation wrong)
-}

{- 
Task 1 
  Implement a function exM that does modular exponentiation of x^y 
  in polynomial time, by repeatedly squaring modulo N.
  E.g., x^33 mod 5 can be computed by means of
  x^33 (mod 5) = x^32 (mod 5) * x (mod 5)
  x^32 (mod N) is computed in five steps by means of repeatedly squaring modulo N:
  x (mod N) -> x^2 (mod N) -> x^4  (mod N) -> ...-> x^32 (mod N):
  If this explanation is too concise, look up relevant literature
-}

-- current solution: functional version of the algorithm found on wikipedia 
-- http://en.wikipedia.org/wiki/Modular_exponentiation#Memory-efficient_method

exM :: Integer -> Integer -> Integer -> Integer
exM base exponent modulus = exMR 0 1 base exponent modulus 

exMR :: Integer -> Integer -> Integer -> Integer -> Integer -> Integer
exMR i c base exponent modulus = if i < exponent
				  then exMR (i + 1) (mod (c * base) modulus) base exponent modulus
				  else c

-- random tests to assure that our implementation comes up with the same result as the 'regular' mod operation

-- perform 10000 random tests
doRandomTests :: IO Bool
doRandomTests = doRandomTestsR 10000

-- perform a given number of random tests
doRandomTestsR :: Integer-> IO Bool
doRandomTestsR x = 
		      if x > 0 
		      then 
		      do r <- doRandomTest
		         p <- (doRandomTestsR (x - 1))
		         return (p && r)
		      else return True

-- perform a single random test
doRandomTest :: IO Bool
doRandomTest = do 
		   x <- (getRandomInt 1000)
		   y <- (getRandomInt 1000) 
		   z <- (getRandomInt 1000) 
		   if 
		    toInteger(expM (toInteger(x+1)) (toInteger(y+1)) (toInteger(z+1)))
		      == 
		    toInteger((Lab6.exM (toInteger(x+1)) (toInteger(y+1)) (toInteger(z+1))))
		   then return True
		   else error ("exM gives not the same result as mod for "	 ++ (show (x+1)) ++ " , "  ++ (show (y+1)) ++ " ," ++ (show (z+1)))

{- 
Task2 : 
  Check that your implementation is more efficient than expM by 
  running a number of relevant tests and documenting the results.
-}

{-
Bad news! It's slower and less efficient! :(  

*Lab6> expM 5 5000000 3			1	( 0.15 secs,   25264776 bytes)
*Lab6> Lab6.exM 5 5000000 3		1	(11.54 secs, 2459061640 bytes)

*Lab6> expM 537 5000000 319		199	( 0.74 secs,   99215856 bytes)
*Lab6> Lab6.exM 537 5000000 319	199	(11.20 secs, 2458988504 bytes)

*Lab6> expM 537 50000000 319		23	(9.50 secs, 1053698392 bytes)
*Lab6> Lab6.exM 537 50000000 319	*** Exception: stack overflow
-}


{-
Task 3 :
  In order to test Fermat's Primality Check (as implemented in function primeF),
  the list of prime numbers generated by Eratosthenes' sieve is useless, for Fermat's
  Primality Check correctly classify the primes as primes. Where the check can go
  wrong is on classifying composite numbers; these can slip through the Fermat test.
  Write a function composites :: [Integer] that generates the infinite list of composite 
  natural numbers. Hint: modify Eratosthenes' sieve, so that instead of throwing away 
  composite numbers, it marks them as false. Next filter out the numbers marked as false.
-}

{-
Task 4 :
  Use the list of composite numbers to test Fermat's primality check. What is the
  least composite number that you can find that fools the check, for testF k with
  k = 1; 2; 3 ? What happens if you increase k?
-}

{-
Task 5 :
  Use the list generated by the following function for a further test of Fermat's primality check.
  Read the entry on Carmichael numbers on Wikipedia to explain what you find.
-}

carmichael :: [Integer]
carmichael = [ (6*k+1)*(12*k+1)*(18*k+1) | 
      k <- [2..], 
      isPrime (6*k+1), 
      isPrime (12*k+1), 
      isPrime (18*k+1) ]

{-
Task 6 : 
  Use the list from the previous exercise to test the Miller-Rabin primality check.
  What do you find?
-}

{-
Task 7 :
  You can use the Miller-Rabin primality check to discover some large Mersenne
  primes. The recipe: take a large prime p, and use the Miller-Rabin algorithm
  to check whether 2p  1 is also prime. Find information about Mersenne primes
  on internet and check whether the numbers that you found are genuine Mersenne
  primes. Report on your findings.
-}